#define _CRT_SECURE_NO_WARNINGS
#include "stdlib.h"
#include "stdio.h"
#include "locale.h"
#include "windows.h"
#include "time.h"

/*Структура вузла стека*/
struct StackElement {
	int x, y, z; /*Поле, що містить координати точки у просторі*/
	StackElement* next; /*Покажчик на наступний елемент стека*/
};

/*Формат дескриптора стека*/
struct StackDescriptor {
	StackElement* top; /*Покажчик на вершину стека*/
	int size; /*Поточний розмір стека (кількість елементів)*/
};

/* Прототипи функцій */
StackDescriptor* StackCreation();
int PushStack(StackDescriptor* sd, int x, int y, int z);
int PopStack(StackDescriptor* sd, int* x, int* y, int* z);
int DestroyStack(StackDescriptor* sd);
int ElementCounter(FILE*& fd);

int main() {
	FILE* fr = NULL; //для встановлення потоку з файлом
	int workWithStack; //пункт меню
	int counter = 0; //для кількості елементів у файлі
	int x, y ,z; //для зберігання введених до консолі координатів
	int minimum = 0; //для нижньої границі задля генерації випадкових чисел
	int maximum = 0; //для верхньої границі задля генерації випадкових чисел
	int count = 0; //для зберігання кількості випадкових елементів задля генерації
	char filename[50]; //з назвою файлу
	int* array = NULL; //на масив array
	bool flag = true; //для повторного вводу пункту меню

	SetConsoleCP(1251); //підключення кирилиці
	SetConsoleOutputCP(1251);

	srand(time(NULL));
	StackDescriptor* sd = StackCreation(); //створюємо стек

	if (sd == NULL) {
		printf("Cтек не створений!");
		exit(0);
	}

	printf("Стек створено!\n");

	do {
		printf("1)Заповнити стек з існуючого файлу;\n2)Створити новий файл;\n3)Заповнити стек випадковими числами.\n");
		scanf_s("%d", &workWithStack); //зчитування пункту меню

		switch (workWithStack) {
		case 1: {
			printf("Введіть назву файлу у вигляді name.txt, з якого бажаєте зчитати дані:\n");
			do {
				fgets(filename, 1024, stdin); //введення назви файлу
			} while (filename[0] == '\n');
			filename[strlen(filename) - 1] = '\0'; //змінює \n на \0

			if ((fr = fopen(filename, "r")) == NULL)//встановлення потоку для роботи з файлом у режимі зчитування та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			counter = ElementCounter(fr); //підрахунок кількості елементів у файлі
			array = (int*)malloc((counter * 3) * sizeof(int)); //виділення пам'яті під динамічний масив array
			for (int k = 0; k < counter * 3; k += 3) { //перенесення елементів з файлу до масиву
				fscanf(fr, "%d %d %d\n", &array[k], &array[k + 1], &array[k + 2]);
			}

			for (int i = 0; i < counter * 3; i+=3) {
				int check = PushStack(sd, array[i], array[i+1], array[i+2]); //розміщення елементів у стеці з масиву
				if (check == -1) {
					printf("Не вистачає пам'яті(стек повний)!");
					return -1;
				}
				else if (check == -2) {
					printf("Стек не існує!");
					return -1;
				}
			}

			fclose(fr); //закриття потоку роботи з файлом
			free(array); //звільнення пам'яті, що була виділена під динамічний масив array
			if ((fr = fopen(filename, "a")) == NULL)//встановлення потоку для роботи з файлом у режимі доповнення та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			break;
		}
		case 2: {
			printf("Введіть назву файлу у вигляді name.txt:\n");
			do {
				fgets(filename, 1024, stdin); //введення назви файлу
			} while (filename[0] == '\n');
			filename[strlen(filename) - 1] = '\0'; //змінює \n на \0

			if ((fr = fopen(filename, "w")) == NULL) //встановлення потоку для роботи з файлом у режимі запису та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			break;
		}
		case 3: {
			printf("Введіть назву файлу у вигляді name.txt, до якого потім будуть переписані елементи стеку:\n");
			do {
				fgets(filename, 1024, stdin); //введення назви файлу

			} while (filename[0] == '\n');
			filename[strlen(filename) - 1] = '\0'; //змінює \n на \0

			if ((fr = fopen(filename, "w")) == NULL) //встановлення потоку для роботи з файлом у режимі запису та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			do {
				printf("Введіть кількість елементів масиву:\n");
				scanf_s("%d", &count); //зчитування пункту меню

				if (count < 1) {
					printf("Введене некоректне значення! Спробуйте ще раз!\n");
				}
			} while (count < 1);

			printf("Введіть нижню границю для генерації випадкових чисел:\n");
			scanf_s("%d", &minimum); //зчитування введеного до консолі значення для нижньої границі задля генерації випадкових чисел
			printf("Введіть верхню границю для генерації випадкових чисел:\n");
			scanf_s("%d", &maximum); //зчитування введеного до консолі значення для верхньої границі задля генерації випадкових чисел

			if (maximum < minimum) { //перевірка на те, щоб верхня границя для генерації випадкових чисел не була меншою за нижню
				printf("Верхня границя не може бути меншою за нижню!\n");
				exit(0);
			}

			for (int i = 0; i < count; i++) {
				x = minimum + rand() % (maximum - minimum + 1); //генерація випадкового числа
				y = minimum + rand() % (maximum - minimum + 1); //генерація випадкового числа
				z = minimum + rand() % (maximum - minimum + 1); //генерація випадкового числа
				PushStack(sd, x, y, z); //розміщення елементів у стеку
				if (!fprintf(fr, "%d %d %d\n", x, y, z)) //запис елементів до файлу
				{
					printf("Виникла помилка запису цілого числа у файл!\n");
					return 1;
				}
			}
			fclose(fr); //закриття потоку роботи з файлом
			if ((fr = fopen(filename, "a")) == NULL) //встановлення потоку для роботи з файлом у режимі доповнення та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			break;
		}
		default: {
			printf("Ви ввели некоректне значення, спробуйте ще раз!\n");
			flag = 0;
			continue;
		}
		}
	} while (!flag);

	for (;;) {
		printf("\nВиберіть тип роботи зі стеком цілих чисел:\n1)Розмістити елемент в стеку;\n2)Зчитування елемента зі стека з видаленням;\n3)Отримати поточний розмір стека;\n4)Відобразити вміст стека на екрані;\n0)Завершити програму;\n");
		scanf_s("%d", &workWithStack); //зчитування пункту меню

		switch (workWithStack) {
		case 0: {
			fclose(fr); //закриття потоку роботи з файлом

			if (ferror(fr)) { //перевірка на наявність помилок при роботі з файлом
				printf("Помилка при закритті файлу %s", filename);
				return 1;
			}

			DestroyStack(sd); //видалення стека
			printf("\nСтек видалено!\n");
			printf("Робота програми завершена!\n");
			return 0;
		}
		case 1: {
			printf("Введіть координати точки, яку бажаєте додати до стеку:\nx = ");
			scanf_s("%d", &x);
			printf("y = ");scanf_s("%d", &y);
			printf("z = ");scanf_s("%d", &z);
			int check = PushStack(sd, x, y, z); //розміщення введеного цілого числа в стеці

			if (check == -1) {
				printf("\nНе вистачає пам'яті(стек повний)!\n");
				exit(0);
			}
			else if (check == -2) {
				printf("\nСтеку не існує!\n");
				exit(0);
			}

			if (!fprintf(fr, "%d %d %d\n", x, y, z)) //запис елементів до файлу
			{
				printf("Виникла помилка запису цілого числа у файл!\n");
				return 1;
			}

			break;
		}
		case 2: {
			int check = PopStack(sd, &x, &y, &z); //видалення елементу стеку

			if (check == -2) {
				printf("\nСтек не існує!");
				exit(0);
			}
			else if (check == -3) {
				printf("\nCтек вже порожній!\n");
				exit(0);
			}

			fclose(fr); //закриття потоку роботи з файлом

			if (ferror(fr)) { //перевірка на наявність помилок при роботі з файлом
				printf("Помилка при закритті файлу %s", filename);
				return 1;
			}

			if ((fr = fopen(filename, "w")) == NULL) //встановлення потоку для роботи з файлом у режимі запису та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			array = (int*)malloc(sizeof(int) * sd->size * 3); //виділення пам'яті під динамічний масив array
			StackElement* tIndex = sd->top; //оголошення та задання адреси верхівки стеку покажчику структурного типу
			for (int i = 0; i < sd->size; i+=3) {
				array[i] = tIndex->x; //запис цілих чисел з полей елементів стеку num до масиву array
				array[i+1] = tIndex->y;
				array[i+2] = tIndex->z;
				if (sd->size - i/3 != 1) {
					tIndex = tIndex->next;
				}
			}

			for (int i = sd->size - 1; i >= 0; i--) {
				if (!fprintf(fr, "%d %d %d\n", x, y, z)) //запис елементів до файлу
				{
					printf("Виникла помилка запису цілого числа у файл!\n");
					return 1;
				}
			}
			free(array); //вивільнення пам'яті, що була виділена під динамічний масив array
			printf("Координати точки в просторі, яку було видалено зі стеку:\nх = %d\ny = %d\nz = %d\n", x, y, z); //вивід видаленого елементу на консоль
			break;
		}
		case 3: {
			printf("\nПоточний розмір стеку (в елементах) - %d \n\n", sd->size);
			break;
		}
		case 4: {
			fclose(fr); //закриття потоку роботи з файлом

			if (ferror(fr)) { //перевірка на помилки при роботі з файлом
				printf("Помилка при закритті файлу %s", filename);
				return 1;
			}

			if ((fr = fopen(filename, "r")) == NULL) //встановлення потоку для роботи з файлом у режимі зчитування та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			array = (int*)malloc(sd->size * 3 * sizeof(int)); //виділення пам'яті під динамічний масив array
			
			for (int k = 0; k < sd->size * 3; k += 3) { //зчитування цілих чисел з файлу до масиву array
				fscanf(fr, "%d %d %d\n", &array[k], &array[k + 1], &array[k + 2]);
			}

			for (int i = 0; i < sd->size * 3; i+=3) {
				printf("Елемент [%d]:\nx = %d\ny = %d\nz = %d\n\n", i/3 + 1, array[i], array[i+1], array[i+2]); //вивід значень, що записані в полях num елементів стеку
			}

			fclose(fr); //закриття потоку роботи з файлом
			if ((fr = fopen(filename, "a")) == NULL) //встановлення потоку для роботи з файлом у режимі доповнення та перевірка на помилки
			{
				printf("Виникла помилка при відкритті файлу %s! \n", filename);
				exit(0);
			}
			free(array); //звільнення пам'яті, що була виділена під динамічний масив array
			break;
		}
		default: {
			printf("Ви ввели некоректне значення, спробуйте ще раз!\n");
			continue;
		}
		}
	}
}

/*Функція створення стека
Вихід:
Адреса на створений стек
*/
StackDescriptor* StackCreation(void) {
	StackDescriptor* sd; //оголошення дескриптору стеку
	sd = (StackDescriptor*)malloc(sizeof(StackDescriptor)); //виділення пам'яті під дескриптор стеку

	if (!sd)
		return NULL;/*стек не створений*/

	else { /*стек утворений*/
		sd->top = NULL; /*ініціалізація покажчика на вершину стека*/
		sd->size = 0; /*ініціалізація розміру стека*/
		return sd;
	}
}


/*Функція включення елемента до стека
Вхід:
Дескриптор стеку sd
Ціле число number
Вихід:
-1-у випадку, якщо стек переповнений
-2-у випадку, якщо стек не існує
0-при вдалому виконанню функції
*/
int PushStack(StackDescriptor* sd, int x, int y, int z) {
	StackElement* sn; /*покажчик на новий елемент стеку*/
	if (!sd) /*стек не існує!*/
		return -2;
	sn = (StackElement*)malloc(sizeof(StackElement)); /*виділення пам'яті під новий елемент стеку*/
	if (!sn) /*не вистачає пам'яті (стек повний)*/
		return -1;
	sn->x = x; //присвоєння полю num елементу стеку значення елементу з масиву array
	sn->y = y;
	sn->z = z;
	sn->next = sd->top; /*встановлення покажчика на наступний елемент стеку*/
	sd->size++; /*зміна поточного розміру стека*/
	sd->top = sn; /*встановлення покажчика на вершину стека в дескрипторі*/
	return 0;
}

/*Функція вибірки елемента зі стеку
Вхід:
Дескриптор стеку
Змінна, в яку запишеться ціле число з видаленого елементу стеку number
Вихід:
-3-у випадку, якщо стек порожній
-2-у випадку, якщо стек не існує
0-при нормальному завершенню виконання функції
*/
int PopStack(StackDescriptor* sd, int* x, int* y, int* z) {
	StackElement* pDel; /*адреса елементу стеку, що буде видалений*/

	if (!sd) /*стек не існує*/
		return -2;

	if (!sd->top) /*стек вже порожній (underflow)*/
		return -3;

	else { /*вибірка елемента з верхівки стека*/
		*x = sd->top->x; /*передаються дані з елемента*/
		*y = sd->top->y;
		*z = sd->top->z;
		pDel = sd->top; /*зберігається адреса елемента стеку, що буде видалений*/
		sd->top = sd->top->next; //вершиною стека стає наступний елемент
		sd->size--; /*зміна поточного розміру стека*/
		free(pDel); /*звільняється пам'ять, що була виділена під елемент стеку*/
		return 0;
	}
}

/*Функція видалення стека
Вхід:
Дескриптор стеку, який буде видалений
Вихід:
-2-у випадку, якщо стеку не існує
0-при нормальному завершення роботи функції
*/
int DestroyStack(StackDescriptor* sd) {
	StackElement* pDel; /*адреса тимчасового елемента стеку*/

	if (!sd) /*стек не існує*/
		return -2;

	/*якщо стек не порожній - спершу слід видалити всі елементи!*/
	while (sd->top) { /*обхід елементів стека*/
		pDel = sd->top; /*збереження адреси вершини стека для видалення*/
		sd->top = sd->top->next; /*задання верхівкою стеку елемент, який іде після неї*/
		free(pDel); /*видалення колишньої верхівки стека*/
	}
	free(sd); /*звільняється пам'ять дескриптора стека*/
	return 0;
}

/*Функція для підрахунку кількості елементів у файлі
Значення, що повертається функцією:
Кількість елементів у файлі count
Зміст параметрів, що передаються:
Файловий дескриптор fd*/
int ElementCounter(FILE*& fd) {
	int count = 0; //змінна для підрахунку кількості елементів, що зберігається у файлі

	while (!feof(fd)) {
		fscanf(fd, "%*d %*d %*d\n");
		count++;
	}
	rewind(fd);
	if (ferror(fd)) {
		printf("Не переміщено показник в початок файлу\n");
		exit(0);
	}
	return count;
}